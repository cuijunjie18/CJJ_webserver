# 线程同步机制包装类

## 初学 
该机制主要用于防止多线程执行过程的数据竞争问题，确保任意时刻只有一个线程能够进入临界代码区.

主要实现有如下三种做法.

- 信号量
- 互斥锁
- 条件变量(较难理解)

## 参考

条件变量的理解： https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html

## deepseek理解
好的，这是一个非常核心的操作系统/多线程编程问题。互斥锁、信号量和条件变量是用于同步和协调多线程或多进程行为的工具，但它们的设计目的和使用方式有显著区别。

下面我将详细解释三者的区别与作用。
---

### 1. 互斥锁

**核心思想：独占访问，提供互斥。**

**作用：**
保护共享资源（也称为**临界区**），确保在同一时刻只有一个线程可以访问该资源。这是为了防止**竞态条件**，即多个线程同时读写数据导致的数据不一致问题。

**比喻：**
一个单人间厕所的门只有一把钥匙。一个人进去后，锁上门，他独占厕所。他用完后出来，把钥匙交给下一个人。其他人必须等待钥匙可用。

**关键特点：**
*   **两种状态：**  locked（已锁，不可进入）和 unlocked（未锁，可进入）。
*   **所有者：** 一个锁在被某个线程持有后，通常只有这个线程能释放它。
*   **解决的是“互斥”问题**，即“你干的时候我不能干”。

**使用场景：**
*   修改一个全局变量。
*   对一个链表进行插入或删除操作。
*   任何需要原子性（不可中断）执行的一系列操作。

**代码示例 (C++11):**
```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex g_mutex;
int shared_data = 0;

void increment() {
    for (int i = 0; i < 100000; ++i) {
        g_mutex.lock();    // 进入临界区前加锁
        ++shared_data;     // 临界区：安全地修改共享资源
        g_mutex.unlock();  // 离开临界区后解锁
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);

    t1.join();
    t2.join();

    std::cout << "Final value: " << shared_data << std::endl; // 总是 200000
    return 0;
}
```

---

### 2. 信号量

**核心思想：资源计数，控制并发访问的数量。**

**作用：**
信号量维护了一个计数器，用于管理对**多个同类资源**的访问。它允许一个或多个线程（取决于计数器的值）同时访问一个资源池。

**比喻：**
一个有多间客房的KTV包房。前台有N把钥匙（信号量初始值为N）。来了一个团体，拿走一把钥匙，可用钥匙数减一（P操作）。房间用完后，归还钥匙，可用钥匙数加一（V操作）。如果客人来时发现前台没有钥匙了（计数器为0），他们就必须等待，直到有人归还钥匙。

**关键特点：**
*   **一个计数器：** 其值表示可用资源的数量。
*   **两种原子操作：**
    *   **Wait (P操作)：** 尝试获取资源，计数器减1。如果计数器为0，则阻塞，直到它大于0。
    *   **Post (V操作)：** 释放资源，计数器加1，并唤醒一个等待的线程。
*   **没有所有者概念**，任何线程都可以执行V操作来释放资源。
*   **解决的是“同步”和“调度”问题**，即“最多允许N个同时干”。

**种类：**
*   **二进制信号量：** 计数器值只能是0或1。**它可以用来实现互斥锁**，但通常用于任务同步（更像条件变量）。
*   **计数信号量：** 计数器值可以是任意非负整数。

**使用场景：**
*   **限制同时访问某一资源的线程数量**（例如，数据库连接池最多允许10个连接）。
*   **生产者-消费者问题**（用信号量表示缓冲区中的空位和已存放物品的数量）。
*   线程间的同步（一个线程完成任务后，通过信号量通知另一个线程）。

**代码概念 (伪代码):**
```
// 初始化一个信号量，代表有5个可用资源
Semaphore semaphore = 5;

// 线程A想使用资源
semaphore.wait(); // 如果计数器>0，获取成功并减1；否则阻塞
// ... 使用资源 ...
semaphore.post(); // 释放资源，计数器加1

// 线程B想使用资源
semaphore.wait();
// ... 使用资源 ...
semaphore.post();
```

---

### 3. 条件变量

**核心思想：等待条件成立，用于线程间通信。**

**作用：**
允许线程在某个**条件**不满足时主动**阻塞并释放锁**，等待其他线程修改条件后**通知**它。它总是与一个**互斥锁**结合使用。

**比喻：**
你和朋友约在咖啡馆见面。
1.  你到了之后（获取锁），发现朋友还没来（**条件不满足**）。
2.  你不会一直站在门口问“来了没？”（**忙等待**），而是**先坐下（释放锁，让别人可以进来）**，但你的状态是“等待朋友”（**等待条件变量**）。
3.  你的朋友到了（**修改条件**），他告诉服务员“帮我叫一下等我的人”（**通知条件变量**）。
4.  服务员来叫你（**你被唤醒**），你**重新站起来并确认**朋友是否真的来了（**重新获取锁并检查条件**），然后一起离开。

**关键特点：**
*   **本身不保护资源**，必须与互斥锁配合使用。
*   **核心操作：**
    *   **等待 (wait)：** 这个操作会**原子地**完成三件事：1) 释放互斥锁，2) 阻塞当前线程，3) 在被唤醒后重新获取互斥锁。
    *   **通知 (signal/broadcast)：** 唤醒一个或多个正在等待此条件变量的线程。
*   **解决的是“等待”问题**，即“等某个条件成立了，你再通知我，我才继续干”。避免了“忙等待”，节省CPU资源。

**使用场景：**
*   **生产者-消费者问题**：消费者等待“缓冲区不为空”的条件，生产者生产后通知它。
*   任何需要等待特定事件或状态变化的场景（例如，等待一个任务完成，等待数据准备好）。

**代码示例 (C++11):**
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> data_queue;
bool finished = false; // “条件”

void producer() {
    for (int i = 0; i < 10; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        data_queue.push(i);
        std::cout << "Produced: " << i << std::endl;
    }
    {
        std::lock_guard<std::mutex> lock(mtx);
        finished = true; // 修改条件
    }
    cv.notify_all(); // 通知所有等待的消费者
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        // 等待条件：如果未结束且队列为空，就阻塞并释放锁
        cv.wait(lock, []{ return finished || !data_queue.empty(); });

        // 被唤醒后，先重新获得锁，再检查条件
        if (finished && data_queue.empty()) {
            break;
        }
        int data = data_queue.front();
        data_queue.pop();
        std::cout << "Consumed: " << data << std::endl;
        lock.unlock(); // 可以在消费时提前解锁，提高并发性
        // ... 处理数据 ...
    }
}

int main() {
    std::thread p(producer);
    std::thread c(consumer);

    p.join();
    c.join();

    return 0;
}
```

---

### 总结对比

| 特性 | 互斥锁 (Mutex) | 信号量 (Semaphore) | 条件变量 (Condition Variable) |
| :--- | :--- | :--- | :--- |
| **核心目的** | **互斥**，保护临界区 | **调度**，控制访问资源的人数 | **同步**，等待特定条件成立 |
| **状态** | 锁定/未锁定 | 计数器（整数） | 无状态，需与外部条件变量配合 |
| **关联锁** | 自身就是锁 | 自身就是计数器 | **必须与一个互斥锁配合使用** |
| **关键操作** | lock(), unlock() | wait(P), post(V) | wait(), signal(), broadcast() |
| **所有者** | 有，锁的持有者才能解锁 | 无，任何线程都可以V操作 | 无 |
| **主要应用** | 防止数据竞争 | 限流、资源池、生产者消费者 | 事件通知、生产者消费者 |

**简单记忆：**
*   **只想让一个人进房间？用 `Mutex`。**
*   **想让N个人同时进房间？用 `Semaphore`。**
*   **想等房间里的人出来叫你？用 `Condition Variable` + `Mutex`。**